# 异或

异或规则相同为 0，不同为 1
又称无进位加例如
1 0 1 1 0
^ 0 1 0 1 1
= 1 1 1 0 1

交换率和结合率
a ^ b = b ^ a

(a ^ b) ^ c = a ^ (b ^ c)

规则
a ^ 0 = a

a ^ a = 0

一堆数异或起来，任意排列顺序结果不变
1\^2\^3\^4\^5\^6 === 6\^5\^4\^3\^2\^1

## 巧用异或

```js
// 有一个 number[] 里面只有一个数出现奇数次，其他数都出现偶数次，求这个出现计数次的数

const arr = [1, 2, 2, 3, 3]
let eor = 0

for (let i = 0; i < arr.length; i++) {
  eor ^= arr[i]
}

console.log(eor) // 1
/**
 * 为啥?
 * 出现偶数次的相同的数异或起来就是0
 * 例如 2 2 2 2
 * 2 ^ 2 = 0 , 0 ^ 2 = 2, 2 ^ 2 = 0
 * 但是奇数次
 * 例如 3 3 3
 * 3 ^ 3 = 0, 0 ^ 3 = 3
 * /
```

例 2，一个数组有两个数出现奇数次，其他都出现偶数次。
不妨假设两个数为 a 和 b，那么使用 eor 全部异或一遍的结果就是 a^b 且不等于 0。由于结果不为 0 那肯定这两个数在某一位或某几个位上数不相等（0、1 或者 1、0），即只要是 eor 某一位为 1 那么 a 和 b 肯定在这一位不相等，根据这一位去划分成两部分（为了方便取最后一个是 1 的那一位）
eor' 只去异或这一位为 0 或为 1 的数，那肯定能拿到 a 或者 b
再用 eor 去异或 eor'再得到另外一个数。
![有两个数出现奇数次](/img/%E5%BC%82%E6%88%96.png)

```js
const arr = [1, 2, 2, 3]
let eor = 0
let eor1 = 0
for (let i = 0; i < arr.length; i++) {
  eor ^= arr[i]
}

// 开始分类，就取最后一个是1的那位，进行区分
/*
  例如： 0010, 0001, 0011, 0110
  这就分成了 0010, 0110 和 0001, 0011
  前面一组第三位是1，后面一组第四位是1
  使用 a & (~a + 1)的方式获取最后一个1
  */
const rightOne = eor & (~eor + 1)
for (let j = 0; j < arr.length; j++) {
  // 这里等于1或者等于0 都行，因为这两个数必定不在同一组，拿到哪一个都行(这么说错了，这个rightOne结构是0000100，这种去与别人结果肯定是0000?00这种结果是0很好说就是那一位是0的一组，那一位如果是1的那组结果0000100好像不等于1。所以如果相等于1我们要写成等于 rightOne)
  if ((arr[j] & rightOne) === 0) {
    eor1 = arr[j]
  }
}

console.log(eor1, eor ^ ero1) // 1 3
```

![](/img/%E8%8E%B7%E5%8F%96%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA1.png)
